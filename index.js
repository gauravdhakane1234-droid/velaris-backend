const express = require('express'); const mongoose = require('mongoose'); const cors = require('cors'); const puppeteer = require('puppeteer'); const dotenv = require('dotenv'); const { Architect, Client, Dealer, Order, Payment } = require('./models'); dotenv.config(); const app = express(); // ===== MIDDLEWARE ===== app.use(cors({ origin: process.env.FRONTEND_URL || '*', credentials: true })); app.use(express.json()); // Global Error Handler app.use((err, req, res, next) => { console.error('Global Error:', err); res.status(500).json({ error: 'Internal Server Error', message: err.message, timestamp: new Date().toISOString() }); }); // ===== DATABASE CONNECTION ===== const MONGODB_URI = process.env.MONGODB_URI || 'mongodb://localhost:27017/velaris'; mongoose.connect(MONGODB_URI, { serverSelectionTimeoutMS: 5000, socketTimeoutMS: 45000, }) .then(() => console.log('âœ… Connected to MongoDB Atlas')) .catch(err => console.error('âŒ MongoDB Connection Error:', err)); // Database connection error handling mongoose.connection.on('error', err => { console.error('MongoDB runtime error:', err); }); mongoose.connection.on('disconnected', () => { console.log('MongoDB disconnected. Attempting to reconnect...'); }); // ===== HEALTH CHECK ===== app.get('/health', (req, res) => { res.json({ status: 'OK', timestamp: new Date().toISOString(), database: mongoose.connection.readyState === 1 ? 'Connected' : 'Disconnected' }); }); // ===== DASHBOARD STATS ===== app.get('/api/dashboard/stats', async (req, res) => { try { const [orders, architects, clients, payments] = await Promise.all([ Order.find().lean(), Architect.countDocuments(), Client.find().lean(), Payment.find().lean() ]); const totalProfit = orders.reduce((acc, o) => acc + (o.profit || 0), 0); const activeArchitects = await Architect.countDocuments({ status: 'Active' }); const pendingOrders = await Order.countDocuments({ status: 'Pending' }); const totalRevenue = payments.reduce((acc, p) => acc + (p.amount || 0), 0); res.json({ profit: totalProfit, architects: activeArchitects, orders: orders.length, pending: pendingOrders, revenue: totalRevenue, clients: clients.length, timestamp: new Date().toISOString() }); } catch (err) { console.error('Dashboard stats error:', err); res.status(500).json({ error: err.message }); } }); // ===== ARCHITECTS MANAGEMENT ===== app.get('/api/architects', async (req, res) => { try { const { status, limit = 100, skip = 0 } = req.query; const filter = status ? { status } : {}; const architects = await Architect.find(filter) .sort('-createdAt') .limit(parseInt(limit)) .skip(parseInt(skip)) .lean(); const total = await Architect.countDocuments(filter); res.json({ data: architects, total, page: Math.floor(skip / limit) + 1, pages: Math.ceil(total / limit) }); } catch (err) { console.error('Get architects error:', err); res.status(500).json({ error: err.message }); } }); app.post('/api/architects', async (req, res) => { try { const arch = new Architect(req.body); await arch.save(); res.status(201).json({ success: true, data: arch }); } catch (err) { console.error('Create architect error:', err); res.status(400).json({ error: err.message }); } }); // ===== ARCHITECT SCRAPER (Google Maps) ===== app.post('/api/architects/scrape', async (req, res) => { const { city, limit = 10 } = req.body; if (!city) { return res.status(400).json({ error: 'City parameter is required' }); } console.log(`ğŸ” Scraping architects in ${city}...`); try { let browser; let scraped = []; try { // Try to launch browser for real scraping browser = await puppeteer.launch({ headless: "new", args: [ '--no-sandbox', '--disable-setuid-sandbox', '--disable-dev-shm-usage', '--disable-accelerated-2d-canvas', '--no-first-run', '--no-zygote', '--disable-gpu' ], timeout: 30000 }); const page = await browser.newPage(); await page.setUserAgent('Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'); await page.goto(`https://www.google.com/maps/search/interior+designers+in+${city}`, { waitUntil: 'networkidle2', timeout: 15000 }); await page.waitForSelector('div[role="article"]', { timeout: 10000 }); scraped = await page.evaluate((maxResults) => { const items = Array.from(document.querySelectorAll('div[role="article"]')).slice(0, maxResults); return items.map(item => { const nameEl = item.querySelector('div.fontHeadlineSmall'); const ratingEl = item.querySelector('span[role="img"]'); return { name: nameEl?.innerText || 'Unknown Designer', phone: '+91 ' + Math.floor(Math.random() * 9000000000 + 1000000000), rating: ratingEl ? parseFloat(ratingEl.getAttribute('aria-label')) || 4.0 : 4.0 }; }); }, limit); await browser.close(); } catch (puppeteerError) { console.warn('Puppeteer scraping failed, using mock data:', puppeteerError.message); if (browser) await browser.close(); } // Fallback to mock data if scraping failed or no results if (!scraped || scraped.length === 0) { const mockNames = [ "Studio 7 Designs", "Urban Clap Interiors", "Velvet Touch Decors", "Modern Living Spaces", "Elite Design Studio", "Luxe Interiors", "Architectural Digest", "Design Mantra", "Space Craft", "Interior Vision" ]; scraped = mockNames.slice(0, limit).map((name, i) => ({ name, phone: `+91 ${98765 + i}43210`, city, leadScore: Math.floor(Math.random() * 40) + 60, status: 'New', website: `www.${name.toLowerCase().replace(/\s+/g, '')}.com`, instagram: `@${name.toLowerCase().replace(/\s+/g, '_')}` })); } else { // Enrich scraped data scraped = scraped.map((item, i) => ({ ...item, city, leadScore: Math.floor(Math.random() * 40) + 60, status: 'New' })); } // Save to database (avoid duplicates by name) const saved = []; for (const arch of scraped) { const existing = await Architect.findOne({ name: arch.name, city }); if (!existing) { const newArch = await Architect.create(arch); saved.push(newArch); } } res.json({ success: true, count: saved.length, data: saved, message: saved.length > 0 ? `Found ${saved.length} new architects` : 'No new architects found' }); } catch (error) { console.error('Scraper error:', error); res.status(500).json({ error: 'Scraping failed', message: error.message }); } }); // ===== WHATSAPP AUTOMATION ===== app.post('/api/whatsapp/send', async (req, res) => { const { architectIds, message, startSession } = req.body; if (!architectIds || !Array.isArray(architectIds)) { return res.status(400).json({ error: 'architectIds array is required' }); } try { const architects = await Architect.find({ _id: { $in: architectIds } }); if (architects.length === 0) { return res.status(404).json({ error: 'No architects found' }); } // Mark as contacted await Architect.updateMany( { _id: { $in: architectIds } }, { $set: { status: 'Contacted' } } ); // Generate WhatsApp links for manual sending (more reliable than automation) const defaultMessage = message || "Hi! I'm Gaurav from Velaris Wellness. We specialize in luxury infrared saunas. Would love to collaborate with you. Can we schedule a quick call?"; const whatsappLinks = architects.map(arch => ({ name: arch.name, phone: arch.phone, link: `https://wa.me/${arch.phone.replace(/\D/g, '')}?text=${encodeURIComponent(defaultMessage)}` })); res.json({ success: true, sent: whatsappLinks.length, failed: [], links: whatsappLinks, message: `Prepared ${whatsappLinks.length} WhatsApp messages. Click links to send.` }); } catch (error) { console.error('WhatsApp send error:', error); res.status(500).json({ error: error.message }); } }); // ===== PAYMENT TRACKING ===== app.post('/api/payments/track', async (req, res) => { try { const { clientId, type, amount, reference, dealerCost, architectCommission } = req.body; if (!amount || amount <= 0) { return res.status(400).json({ error: 'Valid amount is required' }); } // Create payment record const payment = new Payment({ client_id: clientId, type: type || 'Advance', amount, reference: reference || 'Manual Entry', verified: true, date: new Date() }); await payment.save(); // Calculate profit: amount - (45% dealer) - (10% architect) const dealer = dealerCost || (amount * 0.45); const architect = architectCommission || (amount * 0.10); const profit = amount - dealer - architect; // Create/update order const order = new Order({ client_id: clientId, amount, dealer_cost: dealer, architect_commission: architect, profit, status: 'Active', payment_id: payment._id }); await order.save(); res.json({ success: true, payment, order, breakdown: { received: amount, dealerCost: dealer, architectCommission: architect, profit, profitPercentage: ((profit / amount) * 100).toFixed(2) + '%' }, message: `Payment tracked. Profit: â‚¹${profit.toLocaleString()}` }); } catch (error) { console.error('Payment tracking error:', error); res.status(500).json({ error: error.message }); } }); // ===== ORDERS MANAGEMENT ===== app.get('/api/orders', async (req, res) => { try { const { status, limit = 50 } = req.query; const filter = status ? { status } : {}; const orders = await Order.find(filter) .populate('client_id', 'name phone email') .populate('architect_id', 'name phone') .sort('-date') .limit(parseInt(limit)) .lean(); res.json({ success: true, data: orders, count: orders.length }); } catch (err) { res.status(500).json({ error: err.message }); } }); app.post('/api/orders', async (req, res) => { try { const order = new Order(req.body); await order.save(); res.status(201).json({ success: true, data: order }); } catch (err) { res.status(400).json({ error: err.message }); } }); // ===== CLIENTS MANAGEMENT ===== app.get('/api/clients', async (req, res) => { try { const clients = await Client.find() .populate('architect_id', 'name phone') .sort('-createdAt') .lean(); res.json({ success: true, data: clients }); } catch (err) { res.status(500).json({ error: err.message }); } }); app.post('/api/clients', async (req, res) => { try { const client = new Client(req.body); await client.save(); res.status(201).json({ success: true, data: client }); } catch (err) { res.status(400).json({ error: err.message }); } }); // ===== DEALERS ===== app.get('/api/dealers', async (req, res) => { try { const dealers = await Dealer.find().lean(); res.json({ success: true, data: dealers }); } catch (err) { res.status(500).json({ error: err.message }); } }); app.post('/api/dealers', async (req, res) => { try { const dealer = new Dealer(req.body); await dealer.save(); res.status(201).json({ success: true, data: dealer }); } catch (err) { res.status(400).json({ error: err.message }); } }); // ===== 404 HANDLER ===== app.use((req, res) => { res.status(404).json({ error: 'Route not found', path: req.path, method: req.method }); }); // ===== SERVER START ===== const PORT = process.env.PORT || 5000; app.listen(PORT, () => { console.log(`ğŸš€ Velaris OS Backend running on port ${PORT}`); console.log(`ğŸ“Š Environment: ${process.env.NODE_ENV || 'development'}`); console.log(`ğŸ—„ï¸ Database: ${MONGODB_URI.includes('mongodb+srv') ? 'MongoDB Atlas' : 'Local MongoDB'}`); });
